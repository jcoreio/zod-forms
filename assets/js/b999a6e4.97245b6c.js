"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6212],{4018:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>o});var l=d(6070),i=d(5710);const a={},t="Typescript Types",s={id:"api/types",title:"Typescript Types",description:"FieldMeta",source:"@site/docs/api/types.md",sourceDirName:"api",slug:"/api/types",permalink:"/zod-forms/docs/api/types",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api/types.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"createZodForm",permalink:"/zod-forms/docs/api/createZodForm"},next:{title:"useArrayField",permalink:"/zod-forms/docs/api/useArrayField"}},r={},o=[{value:"<code>FieldMeta</code>",id:"fieldmeta",level:2},{value:"<code>FieldPathForValue&lt;Value&gt;</code>",id:"fieldpathforvaluevalue",level:2},{value:"<code>FieldPathForParsedValue&lt;ParsedValue, Value = any&gt;</code>",id:"fieldpathforparsedvalueparsedvalue-value--any",level:2},{value:"<code>FormContextProps</code>",id:"formcontextprops",level:2},{value:"<code>FormStatus</code>",id:"formstatus",level:2},{value:"<code>HtmlFieldInputProps</code>",id:"htmlfieldinputprops",level:2},{value:"<code>SubmitFailedHandler</code>",id:"submitfailedhandler",level:2},{value:"<code>SubmitHandler</code>",id:"submithandler",level:2},{value:"<code>SubmitSuccededHandler</code>",id:"submitsuccededhandler",level:2},{value:"<code>TypedUseArrayField</code>",id:"typedusearrayfield",level:2},{value:"<code>TypedUseField</code>",id:"typedusefield",level:2},{value:"<code>TypedUseHtmlField</code>",id:"typedusehtmlfield",level:2},{value:"<code>UseArrayFieldProps</code>",id:"usearrayfieldprops",level:2},{value:"<code>UseFieldProps</code>",id:"usefieldprops",level:2},{value:"<code>UseHtmlFieldOptions</code>",id:"usehtmlfieldoptions",level:2},{value:"<code>UseHtmlFieldProps</code>",id:"usehtmlfieldprops",level:2},{value:"<code>ValidUseHtmlFieldProps</code>",id:"validusehtmlfieldprops",level:2},{value:"<code>ZodForm</code>",id:"zodform",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h1,{id:"typescript-types",children:"Typescript Types"}),"\n",(0,l.jsx)(n.h2,{id:"fieldmeta",children:(0,l.jsx)(n.code,{children:"FieldMeta"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type FieldMeta = {\n  touched: boolean\n  visited: boolean\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"fieldpathforvaluevalue",children:(0,l.jsx)(n.code,{children:"FieldPathForValue<Value>"})}),"\n",(0,l.jsxs)(n.p,{children:["Type for a ",(0,l.jsx)(n.a,{href:"/zod-forms/docs/api/FieldPath",children:(0,l.jsx)(n.code,{children:"FieldPath"})})," where the value type must extend ",(0,l.jsx)(n.code,{children:"Value"}),".\nThis is useful for typing a property in a custom component; for example,\nin a component that renders a checkbox, you could use"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"type Props = {\n  field: FieldPathForValue<boolean | null | undefined>\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"fieldpathforparsedvalueparsedvalue-value--any",children:(0,l.jsx)(n.code,{children:"FieldPathForParsedValue<ParsedValue, Value = any>"})}),"\n",(0,l.jsxs)(n.p,{children:["Type for a ",(0,l.jsx)(n.a,{href:"/zod-forms/docs/api/FieldPath",children:(0,l.jsx)(n.code,{children:"FieldPath"})})," where value type must extend ",(0,l.jsx)(n.code,{children:"Value"})," and the\nparsed value type must extend ",(0,l.jsx)(n.code,{children:"ParsedValue"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"formcontextprops",children:(0,l.jsx)(n.code,{children:"FormContextProps"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type FormContextProps<T extends z.ZodTypeAny> = {\n  schema: T\n  inverseSchema: z.ZodType<z.input<T>, any, z.output<T>>\n  root: FieldPath<T>\n  initialize: (options: {\n    values?: DeepPartial<z.input<T>>\n    parsedValues?: z.output<T>\n    keepSubmitSucceeded?: boolean\n  }) => void\n  addHandlers: (handlers: {\n    onSubmit?: SubmitHandler<T>\n    onSubmitSucceeded?: SubmitSuccededHandler\n    onSubmitFailed?: SubmitFailedHandler\n  }) => void\n  removeHandlers: (handlers: {\n    onSubmit?: SubmitHandler<T>\n    onSubmitSucceeded?: SubmitSuccededHandler\n    onSubmitFailed?: SubmitFailedHandler\n  }) => void\n  setMeta: <Field extends FieldPath>(\n    field: Field,\n    meta: Partial<FieldMeta>\n  ) => void\n  setValue: <Field extends FieldPath>(\n    field: Field,\n    value: DeepPartial<z.input<Field['schema']>>\n  ) => void\n  setParsedValue: <Field extends FieldPath>(\n    field: Field,\n    value: z.output<Field['schema']>,\n    options?: {\n      normalize?: boolean\n    }\n  ) => void\n  submit: () => void\n  setSubmitStatus: (options: {\n    submitting?: boolean\n    submitError?: Error\n    submitSucceeded?: boolean\n    submitFailed?: boolean\n    submittedParsedValues?: z.output<T>\n    submittedValues?: z.input<T>\n  }) => void\n  arrayActions: {\n    insert: <Field extends ArrayFieldPath>(\n      field: Field,\n      index: number,\n      value: ValueFor<Field>\n    ) => void\n    insertParsed: <Field extends ArrayFieldPath>(\n      field: Field,\n      index: number,\n      parsedValue: ParsedValueFor<Field>\n    ) => void\n    move: (field: ArrayFieldPath, from: number, to: number) => void\n    pop: (field: ArrayFieldPath) => void\n    push: <Field extends ArrayFieldPath>(\n      field: Field,\n      value: ValueFor<Field>\n    ) => void\n    pushParsed: <Field extends ArrayFieldPath>(\n      field: Field,\n      parsedValue: ParsedValueFor<Field>\n    ) => void\n    remove: <Field extends ArrayFieldPath>(field: Field, index: number) => void\n    removeAll: (field: ArrayFieldPath) => void\n    shift: (field: ArrayFieldPath) => void\n    splice: <Field extends ArrayFieldPath>(\n      field: Field,\n      index: number,\n      deleteCount: number,\n      ...values: ValueFor<Field>[]\n    ) => void\n    spliceParsed: <Field extends ArrayFieldPath>(\n      field: Field,\n      index: number,\n      deleteCount: number,\n      ...parsedValues: ParsedValueFor<Field>[]\n    ) => void\n    swap: (field: ArrayFieldPath, indexA: number, indexB: number) => void\n    unshift: <Field extends ArrayFieldPath>(\n      field: Field,\n      value: ValueFor<Field>\n    ) => void\n    unshiftParsed: <Field extends ArrayFieldPath>(\n      field: Field,\n      parsedValue: ParsedValueFor<Field>\n    ) => void\n  }\n  getValues: () => DeepPartial<z.input<T>> | undefined\n  getParsedValues: () => z.output<T> | undefined\n  getInitialValues: () => DeepPartial<z.input<T>> | undefined\n  getInitialParsedValues: () => z.output<T> | undefined\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"formstatus",children:(0,l.jsx)(n.code,{children:"FormStatus"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type FormStatus = {\n  initialized: boolean\n  submitting: boolean\n  submitSucceeded: boolean\n  submitFailed: boolean\n  submitError: boolean\n  valididationError: Error | undefined\n  valid: boolean\n  invalid: boolean\n  pristine: boolean\n  dirty: boolean\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"htmlfieldinputprops",children:(0,l.jsx)(n.code,{children:"HtmlFieldInputProps"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type HtmlFieldInputProps = {\n  name: string\n  type: HTMLInputTypeAttribute\n  value: string\n  checked?: boolean\n  onChange: React.ChangeEventHandler\n  onFocus: React.FocusEventHandler\n  onBlur: React.FocusEventHandler\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"submitfailedhandler",children:(0,l.jsx)(n.code,{children:"SubmitFailedHandler"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type SubmitFailedHandler = (error: Error) => void\n"})}),"\n",(0,l.jsx)(n.h2,{id:"submithandler",children:(0,l.jsx)(n.code,{children:"SubmitHandler"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type SubmitHandler<T extends z.ZodTypeAny> = (\n  parsedValues: z.output<T>,\n  options: {\n    initialValues?: DeepPartial<z.input<T>>\n    initialParsedValues?: z.output<T>\n  }\n) => void | Promise<void>\n"})}),"\n",(0,l.jsx)(n.h2,{id:"submitsuccededhandler",children:(0,l.jsx)(n.code,{children:"SubmitSuccededHandler"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type SubmitSuccededHandler = () => void\n"})}),"\n",(0,l.jsx)(n.h2,{id:"typedusearrayfield",children:(0,l.jsx)(n.code,{children:"TypedUseArrayField"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export interface TypedUseArrayField<T extends z.ZodTypeAny> {\n  <Field extends FieldPathForValue<any[] | null | undefined>>(\n    field: Field\n  ): UseArrayFieldProps<Field>\n  <Path extends PathInSchema<T>>(\n    path: Path\n  ): UseArrayFieldProps<FieldPath<SchemaAt<T, Path>>>\n  <Pathstring extends PathstringInSchema<T>>(\n    path: Pathstring\n  ): UseArrayFieldProps<FieldPath<SchemaAt<T, parsePathstring<Pathstring>>>>\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"typedusefield",children:(0,l.jsx)(n.code,{children:"TypedUseField"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export interface TypedUseField<T extends z.ZodTypeAny> {\n  <Field extends FieldPath>(field: Field): UseFieldProps<Field>\n  <Path extends PathInSchema<T>>(\n    path: Path\n  ): UseFieldProps<FieldPath<SchemaAt<T, Path>>>\n  <Pathstring extends PathstringInSchema<T>>(\n    path: Pathstring\n  ): UseFieldProps<FieldPath<SchemaAt<T, parsePathstring<Pathstring>>>>\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"typedusehtmlfield",children:(0,l.jsx)(n.code,{children:"TypedUseHtmlField"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export interface TypedUseHtmlField<T extends z.ZodTypeAny> {\n  <Field extends FieldPath>(\n    options: UseHtmlFieldOptions<Field, Field['schema']>\n  ): UseHtmlFieldProps<Field>\n  <Path extends PathInSchema<T>>(\n    options: UseHtmlFieldOptions<Path, SchemaAt<T, Path>>\n  ): UseHtmlFieldProps<FieldPath<SchemaAt<T, Path>>>\n  <Path extends PathstringInSchema<T>>(\n    options: UseHtmlFieldOptions<Path, SchemaAt<T, parsePathstring<Path>>>\n  ): UseHtmlFieldProps<FieldPath<SchemaAt<T, parsePathstring<Path>>>>\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"usearrayfieldprops",children:(0,l.jsx)(n.code,{children:"UseArrayFieldProps"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type UseArrayFieldProps<Field extends FieldPath> =\n  NonNullable<z.input<Field['schema']>> extends any[] ?\n    FieldMeta & {\n      setMeta: (meta: Partial<FieldMeta>) => void\n      setParsedValue: (parsedValue: z.output<Field['schema']>) => void\n      setValue: (\n        value: DeepPartial<z.input<Field['schema']>>,\n        options?: {\n          normalize?: boolean\n        }\n      ) => void\n      elements: FieldPath<SchemaAt<Field['schema'], [number]>>[]\n      error?: string\n      dirty: boolean\n      pristine: boolean\n      valid: boolean\n      invalid: boolean\n    }\n  : { ERROR: 'not an array field' }\n"})}),"\n",(0,l.jsx)(n.h2,{id:"usefieldprops",children:(0,l.jsx)(n.code,{children:"UseFieldProps"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type UseFieldProps<Field extends FieldPath> = FieldMeta & {\n  setMeta: (meta: Partial<FieldMeta>) => void\n  setParsedValue: (parsedValue: z.output<Field['schema']>) => void\n  setValue: (\n    value: DeepPartial<z.input<Field['schema']>>,\n    options?: {\n      normalize?: boolean\n    }\n  ) => void\n  value: DeepPartial<z.input<Field['schema']>> | undefined\n  parsedValue: z.output<Field['schema']> | undefined\n  initialValue: DeepPartial<z.input<Field['schema']>> | undefined\n  initialParsedValue: z.output<Field['schema']> | undefined\n  error?: string\n  dirty: boolean\n  pristine: boolean\n  valid: boolean\n  invalid: boolean\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"usehtmlfieldoptions",children:(0,l.jsx)(n.code,{children:"UseHtmlFieldOptions"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type UseHtmlFieldOptions<\n  Field,\n  Schema extends z.ZodTypeAny = Field extends FieldPath<infer S> ? S\n  : z.ZodTypeAny,\n> = {\n  field: Field\n  type: z.input<Schema> extends boolean | null | undefined ? 'checkbox'\n  : Exclude<HTMLInputTypeAttribute, 'checkbox'>\n  normalizeOnBlur?: boolean\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"usehtmlfieldprops",children:(0,l.jsx)(n.code,{children:"UseHtmlFieldProps"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type UseHtmlFieldProps<Field extends FieldPath> =\n  z.input<Field['schema']> extends (\n    string | number | bigint | boolean | null | undefined\n  ) ?\n    {\n      input: HtmlFieldInputProps\n      meta: UseFieldProps<Field>\n    }\n  : {\n      ERROR: 'field schema input must be a nullish string, number, boolean or bigint'\n    }\n"})}),"\n",(0,l.jsx)(n.h2,{id:"validusehtmlfieldprops",children:(0,l.jsx)(n.code,{children:"ValidUseHtmlFieldProps"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type ValidUseHtmlFieldProps<Field extends FieldPath> = {\n  input: HtmlFieldInputProps\n  meta: UseFieldProps<Field>\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"zodform",children:(0,l.jsx)(n.code,{children:"ZodForm"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"export type ZodForm<T> = {\n  root: FieldPath<T>\n  get: FieldPath<T>['get']\n  FormProvider: React.ComponentType<{ children: JSX.Element }>\n  useFormStatus: () => FormStatus\n  useFormValues: () => {\n    values: DeepPartial<z.input<T>> | undefined\n    parsedValues: z.output<T> | undefined\n    initialValues: DeepPartial<z.input<T>> | undefined\n    initialParsedValues: z.output<T> | undefined\n  }\n  useInitialize: (\n    options: {\n      values?: DeepPartial<z.input<T>>\n      parsedValues?: z.output<T>\n      keepSubmitSucceeded?: boolean\n    },\n    deps: DependencyList = [options.values, options.parsedValues]\n  ) => void\n  useSubmit: (handlers: {\n    onSubmit?: SubmitHandler<T>\n    onSubmitSucceeded?: SubmitSuccededHandler\n    onSubmitFailed?: SubmitFailedHandler\n  }) => React.FormEventHandler\n  useArrayField: TypedUseArrayField<T>\n  useField: TypedUseField<T>\n  useHtmlField: TypedUseHtmlField<T>\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(u,{...e})}):u(e)}},5710:(e,n,d)=>{d.d(n,{R:()=>t,x:()=>s});var l=d(758);const i={},a=l.createContext(i);function t(e){const n=l.useContext(a);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);